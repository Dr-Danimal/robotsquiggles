<!DOCTYPE html>
<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
  <meta content="utf-8" http-equiv="encoding" />

  <script src="url.js"></script>
  <script src="./jquery-3.5.1.min.js"></script>
  <script src="./two.min.js"></script>
  <script src="./a.out.js"></script>
  <script>
    Module.onRuntimeInitialized = async (_) => {
      const api = {
        version: Module.cwrap("version", "number", []),
      };
      console.log(api.version());
    };
  </script>
  <style>
    .assets {
      display: none;
    }
  </style>
</head>
<body>
  <div id="draw-animation" />
  <div class="assets">
    <!-- letter "C" made in Adobe Illustrator CS5 -->
    <svg
      version="1.1"
      xmlns="http://www.w3.org/2000/svg"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:a="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"
      x="0px"
      y="0px"
      width="202px"
      height="264px"
      overflow="visible"
      enable-background="new -0.469 -0.136 202 264"
      xml:space="preserve"
    >
      <path
        fill="none"
        stroke="#000000"
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-miterlimit="10"
        d="M200.5,204.792
        c0,0-35.703,58.341-99.988,58.341C36.223,263.132,0.5,210.862,0.5,131.531C0.5,52.204,38.584,0.5,100.5,0.5
        c61.924,0,85.354,51.704,85.354,51.704"
      />
    </svg>
  </div>
</body>
<footer>
  <script>
    function rand_gray() {
      var value = Math.random() * 0xf + 0x50;
      var grayscale = (value << 16) | (value << 8) | value;
      return "#" + grayscale.toString(16);
    }

    function field_tiles(two, bg, tile_width, spacer) {
      for (var i = 0; i < 6; i++) {
        var x = tile_width * (i + 0.5) + spacer;
        for (var j = 0; j < 6; j++) {
          var y = tile_width * (j + 0.5) + spacer;
          var rec = two.makeRectangle(x, y, tile_width, tile_width);
          rec.fill = rand_gray();
          bg.add(rec);
        }
      }
    }

    var elem = document.getElementById("draw-animation");
    var two = new Two({ fullscreen: true, autostart: true }).appendTo(elem);

    const tile_width = Math.ceil((two.width - 100) / 6);
    const spacer = (two.width - tile_width * 6) / 2;
    const field_center = spacer + tile_width * 3;
    const field_top = spacer;
    const field_bot = tile_width * 6 + spacer;

    const goal_radius = tile_width / 5;
    const goal_linewidth = 15;
    const goal_fill = "none";
    const goal_stroke = "rgb(0, 0, 0)";

    var background = two.makeGroup();
    field_tiles(two, background, tile_width, spacer);

    var left_autonline = two.makeLine(
      field_center - 10,
      field_top,
      field_center - 10,
      field_bot
    );

    var right_autonline = two.makeLine(
      field_center + 10,
      field_top,
      field_center + 10,
      field_bot
    );

    var left_line = two.makeLine(
      spacer + tile_width + 2.5,
      field_top,
      spacer + tile_width + 2.5,
      field_bot
    );

    var right_line = two.makeLine(
      tile_width * 5.5 - spacer - 2.5,
      field_top,
      tile_width * 5.5 - spacer - 2.5,
      field_bot
    );

    var leftdoubletop_line = two.makeLine(
      spacer,
      field_center - 10,
      spacer + tile_width,
      field_center - 10
    );

    var leftdoublebot_line = two.makeLine(
      spacer,
      field_center + 10,
      spacer + tile_width,
      field_center + 10
    );

    var rightdoubletop_line = two.makeLine(
      tile_width * 6.5 - spacer,
      field_center - 10,
      tile_width * 5.5 - spacer,
      field_center - 10
    );

    var rightdoublebot_line = two.makeLine(
      tile_width * 6.5 - spacer,
      field_center + 10,
      tile_width * 5.5 - spacer,
      field_center + 10
    );

    var lines = two.makeGroup(
      left_autonline,
      right_autonline,
      left_line,
      right_line,
      leftdoubletop_line,
      leftdoublebot_line,
      rightdoublebot_line,
      rightdoubletop_line
    );
    lines.linewidth = 5;
    lines.stroke = "#fff";

    var topcenter_goal = two.makeCircle(
      two.width / 2,
      spacer + goal_radius + goal_linewidth / 2,
      goal_radius
    );

    var topleft_goal = two.makeCircle(
      spacer + goal_radius + goal_linewidth / 2,
      spacer + goal_radius + goal_linewidth / 2,
      goal_radius
    );

    var topright_goal = two.makeCircle(
      two.width - spacer - goal_radius - goal_linewidth / 2,
      spacer + goal_radius + goal_linewidth / 2,
      goal_radius
    );

    var leftcenter_goal = two.makeCircle(
      spacer + goal_radius + goal_linewidth / 2,
      field_center,
      goal_radius
    );

    var center_goal = two.makeCircle(two.width / 2, field_center, goal_radius);

    var rightcenter_goal = two.makeCircle(
      two.width - spacer - goal_radius - goal_linewidth / 2,
      field_center,
      goal_radius
    );

    var botleft_goal = two.makeCircle(
      spacer + goal_radius + goal_linewidth / 2,
      two.height - spacer - goal_radius * 2,
      goal_radius
    );

    var botcenter_goal = two.makeCircle(
      two.width / 2,
      two.height - spacer - goal_radius * 2,
      goal_radius
    );

    var botright_goal = two.makeCircle(
      two.width - spacer - goal_radius - goal_linewidth / 2,
      two.height - spacer - goal_radius * 2,
      goal_radius
    );

    var goals = two.makeGroup(
      topleft_goal,
      topcenter_goal,
      topright_goal,
      leftcenter_goal,
      center_goal,
      rightcenter_goal,
      botleft_goal,
      botcenter_goal,
      botright_goal
    );
    goals.fill = goal_fill;
    goals.stroke = goal_stroke;
    goals.linewidth = goal_linewidth;

    $(function () {
      var $window = $(window);
      var radius = 40,
        editColor = "rgb(79, 128, 255)";
      var two = new Two({
        fullscreen: true,
        autostart: true,
      }).appendTo(document.body);

      // var letter = two.interpret(document.querySelector(".assets svg"));
      // console.log(letter.children[0].vertices);

      var polygon = new Two.Path(
        [
          new Two.Anchor(100, 72.975, 0, 0, 0, 0, "M"),
          new Two.Anchor(0, 131.315, 64, 0, -64, 0, "C"),
          new Two.Anchor(-100, 0, 0, 80, 0, -80, "C"),
          new Two.Anchor(0, -131, -62, 0, 62, 0, "C"),
          new Two.Anchor(85, -79, 0, 0, 0, 0, "C"),
        ],
        false,
        true,
        true
      );
      polygon.linewidth = radius;
      polygon.cap = polygon.join = "round";
      polygon.noFill().stroke = "#333";

      var resize = function () {
        var cx = two.width / 2;
        var cy = two.height / 2;
        var rect = polygon.getBoundingClientRect();
        polygon.translation.set(cx - rect.width / 2, cy - rect.height / 2);
      };
      two.bind("resize", resize);
      resize();

      var path = two.makeGroup();
      path.add(polygon);

      polygon.vertices.forEach(function (anchor) {
        // TODO: only set one control point and make the other control point the
        // same magnitude in the opposite direction from the point

        // TODO: figure out an interface for adding/removing points
        var p = two.makeCircle(0, 0, radius / 4);
        var l = two.makeCircle(0, 0, radius / 4);
        var r = two.makeCircle(0, 0, radius / 4);

        console.log(anchor);

        p.translation.copy(anchor);
        l.translation.copy(anchor.controls.left).addSelf(anchor);
        r.translation.copy(anchor.controls.right).addSelf(anchor);
        p.noStroke().fill = l.noStroke().fill = r.noStroke().fill = editColor;

        var ll = new Two.Path([
          new Two.Anchor().copy(p.translation),
          new Two.Anchor().copy(l.translation),
        ]);
        var rl = new Two.Path([
          new Two.Anchor().copy(p.translation),
          new Two.Anchor().copy(r.translation),
        ]);
        rl.noFill().stroke = ll.noFill().stroke = editColor;

        var g = two.makeGroup(rl, ll, p, l, r);
        g.translation.addSelf(polygon.translation);
        // letter.add(g);
        path.add(g);

        p.translation.bind(Two.Events.change, function () {
          anchor.copy(this);
          l.translation.copy(anchor.controls.left).addSelf(this);
          r.translation.copy(anchor.controls.right).addSelf(this);
          ll.vertices[0].copy(this);
          rl.vertices[0].copy(this);
          ll.vertices[1].copy(l.translation);
          rl.vertices[1].copy(r.translation);
        });
        l.translation.bind(Two.Events.change, function () {
          anchor.controls.left.copy(this).subSelf(anchor);
          ll.vertices[1].copy(this);
        });
        r.translation.bind(Two.Events.change, function () {
          anchor.controls.right.copy(this).subSelf(anchor);
          rl.vertices[1].copy(this);
        });

        // Update the renderer in order to generate the actual elements.
        two.update();

        // Add Interactivity
        addInteractivity(p);
        addInteractivity(l);
        addInteractivity(r);
      });
      // });

      function addInteractivity(shape) {
        var offset = Two.Vector.add(
          shape.parent.parent.translation,
          shape.parent.translation
        );

        var drag = function (e) {
          e.preventDefault();
          var x = e.clientX - offset.x;
          var y = e.clientY - offset.y;
          shape.translation.set(x, y);
        };
        var touchDrag = function (e) {
          e.preventDefault();
          var touch = e.originalEvent.changedTouches[0];
          drag({
            preventDefault: function () {},
            clientX: touch.pageX,
            clientY: touch.pageY,
          });
          return false;
        };
        var dragEnd = function (e) {
          e.preventDefault();
          $window.unbind("mousemove", drag).unbind("mouseup", dragEnd);
        };
        var touchEnd = function (e) {
          e.preventDefault();
          $(window).unbind("touchmove", touchDrag).unbind("touchend", touchEnd);
          return false;
        };

        $(shape._renderer.elem)
          .css({
            cursor: "pointer",
          })
          .bind("mousedown", function (e) {
            e.preventDefault();
            $window.bind("mousemove", drag).bind("mouseup", dragEnd);
          })
          .bind("touchstart", function (e) {
            e.preventDefault();
            $(window).bind("touchmove", touchDrag).bind("touchend", touchEnd);
            return false;
          });
      }
    });

    // function addBackdrop(d) {
    //   var dimensions = d || 50;
    //   var two = new Two({
    //     type: Two.Types.canvas,
    //     width: dimensions,
    //     height: dimensions,
    //   });

    //   var r = dimensions / 10;
    //   var center = dimensions / 2;

    //   var a = two.makeLine(center - r, center, center + r, center);
    //   var b = two.makeLine(center, center - r, center, center + r);

    //   a.stroke = b.stroke = "#aaa";
    //   a.linewidth = b.linewidth = 0.25;

    //   two.update();

    //   var style = document.body.style;
    //   style.backgroundImage =
    //     "url(" + two.renderer.domElement.toDataURL() + ")";
    //   style.backgroundRepeat = "repeat";
    //   style.backgroundSize = dimensions + "px " + dimensions + "px";
    // }
  </script>
</footer>
