[{"/home/bayle/Documents/git/robotsquiggles/web-react/src/index.tsx":"1","/home/bayle/Documents/git/robotsquiggles/web-react/src/reportWebVitals.ts":"2","/home/bayle/Documents/git/robotsquiggles/web-react/src/components/index.ts":"3","/home/bayle/Documents/git/robotsquiggles/web-react/src/app.tsx":"4","/home/bayle/Documents/git/robotsquiggles/web-react/src/components/new_path.jsx":"5","/home/bayle/Documents/git/robotsquiggles/web-react/src/theme.js":"6","/home/bayle/Documents/git/robotsquiggles/web-react/src/components/sidebar.tsx":"7","/home/bayle/Documents/git/robotsquiggles/web-react/src/components/generated.tsx":"8"},{"size":504,"mtime":1609011732981,"results":"9","hashOfConfig":"10"},{"size":425,"mtime":1608741115116,"results":"11","hashOfConfig":"10"},{"size":28,"mtime":1609101496551,"results":"12","hashOfConfig":"10"},{"size":4697,"mtime":1609189232442,"results":"13","hashOfConfig":"10"},{"size":14841,"mtime":1609189890873,"results":"14","hashOfConfig":"10"},{"size":310,"mtime":1609163659677,"results":"15","hashOfConfig":"10"},{"size":3874,"mtime":1609168242311,"results":"16","hashOfConfig":"10"},{"size":2269,"mtime":1609192427241,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"7xnx51",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/home/bayle/Documents/git/robotsquiggles/web-react/src/index.tsx",[],["37","38"],"/home/bayle/Documents/git/robotsquiggles/web-react/src/reportWebVitals.ts",[],"/home/bayle/Documents/git/robotsquiggles/web-react/src/components/index.ts",[],"/home/bayle/Documents/git/robotsquiggles/web-react/src/app.tsx",[],"/home/bayle/Documents/git/robotsquiggles/web-react/src/components/new_path.jsx",["39"],"import React, { useEffect, useRef } from \"react\";\nimport { useTheme } from \"@material-ui/core\";\nimport Two from \"two.js\";\n\nexport const DrawNewPath = (props) => {\n  const mount = useRef(null);\n  const two = useRef(null);\n  const group = useRef(null);\n\n  const startWidth = useRef(null);\n  const savedBoundingRect = useRef(null);\n  const savedLeft = useRef(null);\n\n  const prevMode = useRef(null);\n  const listeners = useRef([]);\n\n  const theme = useTheme();\n  const editColor = theme.palette.primary.light;\n\n  /**\n   * Modifies the mouse event to fit with the Two canvas coordinates.\n   *\n   * @param e The mouse event\n   *\n   * @returns {x: number, y: number}\n   */\n  const getCursorPosition = (e) => {\n    let x = e.clientX;\n    let y = e.clientY;\n    // relying on savedLeft to tell us if the drawer is open\n    let left = savedBoundingRect.current.left + savedLeft.current ?? 0;\n    let top = savedBoundingRect.current.top;\n    return {\n      x: (x - left) / two.current.scene.scale,\n      y: (y - top) / two.current.scene.scale,\n    };\n  };\n\n  const addInteractivity = (shape) => {\n    const offset = group.current.translation;\n\n    var drag = function (e) {\n      e.preventDefault();\n      const cursor = getCursorPosition(e);\n      var x = cursor.x - offset.x;\n      var y = cursor.y - offset.y;\n      shape.translation.set(x, y);\n    };\n    var touchDrag = function (e) {\n      e.preventDefault();\n      var touch = e.originalEvent.changedTouches[0];\n      drag({\n        preventDefault: function () {},\n        clientX: touch.pageX,\n        clientY: touch.pageY,\n      });\n      return false;\n    };\n    var dragEnd = function (e) {\n      e.preventDefault();\n      window.removeEventListener(\"mousemove\", drag);\n      window.removeEventListener(\"mouseup\", dragEnd);\n    };\n    var touchEnd = function (e) {\n      e.preventDefault();\n      window.removeEventListener(\"touchmove\", touchDrag);\n      window.removeEventListener(\"touchend\", touchEnd);\n      return false;\n    };\n\n    shape._renderer.elem.addEventListener(\"mousedown\", function (e) {\n      e.preventDefault();\n      window.addEventListener(\"mousemove\", drag);\n      window.addEventListener(\"mouseup\", dragEnd);\n    });\n    shape._renderer.elem.addEventListener(\"touchstart\", function (e) {\n      e.preventDefault();\n      window.addEventListener(\"touchmove\", touchDrag);\n      window.addEventListener(\"touchend\", touchEnd);\n      return false;\n    });\n  };\n\n  const createPath = (pathKey) => {\n    const anchors = [];\n    const lastPoint = props.paths.get(pathKey)[\"waypoints\"].length - 1;\n    for (let i = lastPoint; i >= 0; --i) {\n      // iterate backwards through points so we are driving the right direction\n      const p = props.paths.get(pathKey).waypoints[i];\n      let anchor;\n      if (i === lastPoint) {\n        anchor = new Two.Anchor(\n          p.translation.x,\n          p.translation.y,\n          0,\n          100,\n          0,\n          -100,\n          \"M\"\n        );\n        anchors.push(anchor);\n      } else {\n        anchor = new Two.Anchor(\n          p.translation.x,\n          p.translation.y,\n          0,\n          100,\n          0,\n          -100,\n          \"C\"\n        );\n        anchors.push(anchor);\n      }\n      two.current.remove(p);\n      two.current.update(); // render the elements before adding interactivity\n    }\n\n    group.current = two.current.makeGroup();\n\n    const newPath = new Two.Path(anchors, false, true, true);\n    newPath.cap = newPath.join = \"round\";\n    newPath.noFill().stroke = \"#333\";\n    newPath.linewidth = 5;\n    group.current.add(newPath);\n\n    newPath.vertices.forEach(function (anchor) {\n      const p = two.current.makeCircle(0, 0, 10);\n      const r = two.current.makePolygon(0, 0, 10);\n      r.rotation =\n        Math.atan2(anchor.controls.right.y, anchor.controls.right.x) +\n        Math.PI / 2;\n\n      p.translation.copy(anchor);\n      r.translation.copy(anchor.controls.right).addSelf(anchor);\n      p.noStroke().fill = r.noStroke().fill = editColor;\n\n      const rl = new Two.Path([\n        new Two.Anchor().copy(p.translation),\n        new Two.Anchor().copy(r.translation),\n      ]);\n      rl.noFill().stroke = editColor;\n\n      const g = two.current.makeGroup(rl, p, r);\n      g.translation.addSelf(newPath.translation);\n      group.current.add(g);\n\n      p.translation.bind(Two.Events.change, function () {\n        anchor.copy(this);\n        r.translation.copy(anchor.controls.right).addSelf(this);\n        rl.vertices[0].copy(this);\n        rl.vertices[1].copy(r.translation);\n      });\n      r.translation.bind(Two.Events.change, function () {\n        anchor.controls.right.copy(this).subSelf(anchor);\n        rl.vertices[1].copy(this);\n\n        const x = -1 * (anchor.controls.right.x - anchor.x);\n        const y = -1 * (anchor.controls.right.y - anchor.y);\n        const opp = new Two.Vector(x, y);\n        anchor.controls.left.copy(opp).subSelf(anchor);\n\n        r.rotation =\n          Math.atan2(anchor.controls.right.y, anchor.controls.right.x) +\n          Math.PI / 2;\n      });\n\n      // Update the renderer in order to generate the actual elements.\n      two.current.update();\n\n      props.setPaths(\n        new Map(\n          props.paths.set(pathKey, {\n            waypoints: props.paths.get(pathKey).waypoints,\n            vectors: [{ p: p, r: r }, ...props.paths.get(pathKey).vectors],\n            path: newPath,\n          })\n        )\n      );\n    });\n  };\n\n  const nextChar = (str) => {\n    return (\n      str.substring(0, str.length - 1) +\n      String.fromCharCode(str.charCodeAt(str.length - 1) + 1)\n    );\n  };\n\n  const curPath = () => {\n    let curKey = \"A\";\n    for (const k of props.paths.keys()) {\n      if (k.charCodeAt(0) > curKey.charCodeAt(0)) {\n        curKey = k;\n      }\n    }\n    return curKey;\n  };\n\n  const placePoints = (e) => {\n    e.preventDefault();\n\n    const cursor = getCursorPosition(e);\n    const point = two.current.makeCircle(cursor.x, cursor.y, 10);\n    point.fill = editColor;\n    if (props.paths.size === 0) {\n      props.setPaths(\n        new Map(\n          props.paths.set(\"A\", {\n            waypoints: [],\n            vectors: [],\n            path: null,\n          })\n        )\n      );\n    }\n    const pathKey = curPath();\n    props.setPaths(\n      new Map(\n        props.paths.set(pathKey, {\n          waypoints: [point, ...props.paths.get(pathKey).waypoints],\n          vectors: props.paths.get(pathKey).vectors,\n          path: props.paths.get(pathKey).path,\n        })\n      )\n    );\n\n    if (props.paths.get(pathKey)[\"waypoints\"].length > 1) {\n      createPath(pathKey);\n      // create the next path's array\n      props.setPaths(\n        new Map(\n          props.paths.set(nextChar(pathKey), {\n            waypoints: [],\n            vectors: [],\n            path: null,\n          })\n        )\n      );\n      props.setMode(\"EDIT\");\n    }\n  };\n\n  const addMidpoint = () => {\n    // const midpoint = path.current.getPointAt(0.5);\n    // console.log(midpoint);\n    // two.current.makeCircle(midpoint.x, midpoint.y, 10);\n    // const r2 = two.current.makePolygon(0, 0, 10);\n    // r2.rotation =\n    //   Math.atan2(midpoint.controls.right.y, midpoint.controls.right.x) +\n    //   Math.PI / 2;\n    // r2.translation.copy(midpoint.controls.right).addSelf(midpoint);\n  };\n\n  const addNewEventListener = (node, event, handler) => {\n    const listener = { node: node, event: event, handler: handler };\n    for (let i = 0; i < listeners.current.length; ++i) {\n      if (listeners.current[i] === listener) {\n        // the new event is already defined, don't define it again\n        return;\n      }\n    }\n    node.addEventListener(event, handler);\n    listeners.current.push(listener);\n  };\n\n  const removeAllEventListeners = () => {\n    for (let i = 0; i < listeners.current.length; ++i) {\n      const x = listeners.current[i];\n      x.node.removeEventListener(x.event, x.handler);\n    }\n    listeners.current = [];\n  };\n\n  /**\n   * Sets up the field when the component is mounted.\n   */\n  useEffect(() => {\n    const rand_gray = () => {\n      var value = Math.random() * 0xf + 0x50;\n      var grayscale = (value << 16) | (value << 8) | value;\n      return \"#\" + grayscale.toString(16);\n    };\n\n    const field_tiles = (two, bg, tile_width) => {\n      for (var i = 0; i < 6; i++) {\n        var x = tile_width * (i + 0.5);\n        for (var j = 0; j < 6; j++) {\n          var y = tile_width * (j + 0.5);\n          var rec = two.current.makeRectangle(x, y, tile_width, tile_width);\n          rec.fill = rand_gray();\n          bg.add(rec);\n        }\n      }\n    };\n\n    const field = () => {\n      const tile_width = (two.current.scene.scale * two.current.width) / 6;\n      const field_center = tile_width * 3;\n      const field_top = 0;\n      const field_bot = tile_width * 6;\n      const field_right = tile_width * 6;\n\n      const goal_radius = tile_width / 5;\n      const goal_linewidth = tile_width / 8;\n      const goal_fill = \"none\";\n      const goal_stroke = \"rgb(0, 0, 0)\";\n\n      const double_line_space = tile_width / 8;\n      const line_width = tile_width / 12;\n\n      var background = two.current.makeGroup([]);\n      field_tiles(two, background, tile_width);\n\n      var left_autonline = two.current.makeLine(\n        field_center - double_line_space,\n        field_top,\n        field_center - double_line_space,\n        field_bot\n      );\n\n      var right_autonline = two.current.makeLine(\n        field_center + double_line_space,\n        field_top,\n        field_center + double_line_space,\n        field_bot\n      );\n\n      var left_line = two.current.makeLine(\n        tile_width + line_width / 2,\n        field_top,\n        tile_width + line_width / 2,\n        field_bot\n      );\n\n      var right_line = two.current.makeLine(\n        tile_width * 5 - line_width / 2,\n        field_top,\n        tile_width * 5 - line_width / 2,\n        field_bot\n      );\n\n      var leftdoubletop_line = two.current.makeLine(\n        0,\n        field_center - double_line_space,\n        tile_width,\n        field_center - double_line_space\n      );\n\n      var leftdoublebot_line = two.current.makeLine(\n        0,\n        field_center + double_line_space,\n        tile_width,\n        field_center + double_line_space\n      );\n\n      var rightdoubletop_line = two.current.makeLine(\n        tile_width * 5,\n        field_center - double_line_space,\n        tile_width * 6,\n        field_center - double_line_space\n      );\n\n      var rightdoublebot_line = two.current.makeLine(\n        tile_width * 5,\n        field_center + double_line_space,\n        tile_width * 6,\n        field_center + double_line_space\n      );\n\n      var lines = two.current.makeGroup([\n        left_autonline,\n        right_autonline,\n        left_line,\n        right_line,\n        leftdoubletop_line,\n        leftdoublebot_line,\n        rightdoublebot_line,\n        rightdoubletop_line,\n      ]);\n      lines.linewidth = line_width;\n      lines.stroke = \"#fff\";\n\n      var topcenter_goal = two.current.makeCircle(\n        field_center,\n        goal_radius + goal_linewidth / 2,\n        goal_radius\n      );\n\n      var topleft_goal = two.current.makeCircle(\n        goal_radius + goal_linewidth / 2,\n        goal_radius + goal_linewidth / 2,\n        goal_radius\n      );\n\n      var topright_goal = two.current.makeCircle(\n        field_right - goal_radius - goal_linewidth / 2,\n        goal_radius + goal_linewidth / 2,\n        goal_radius\n      );\n\n      var leftcenter_goal = two.current.makeCircle(\n        goal_radius + goal_linewidth / 2,\n        field_center,\n        goal_radius\n      );\n\n      var center_goal = two.current.makeCircle(\n        field_center,\n        field_center,\n        goal_radius\n      );\n\n      var rightcenter_goal = two.current.makeCircle(\n        field_right - goal_radius - goal_linewidth / 2,\n        field_center,\n        goal_radius\n      );\n\n      var botleft_goal = two.current.makeCircle(\n        goal_radius + goal_linewidth / 2,\n        field_bot - goal_radius - goal_linewidth / 2,\n        goal_radius\n      );\n\n      var botcenter_goal = two.current.makeCircle(\n        field_center,\n        field_bot - goal_radius - goal_linewidth / 2,\n        goal_radius\n      );\n\n      var botright_goal = two.current.makeCircle(\n        field_right - goal_radius - goal_linewidth / 2,\n        field_bot - goal_radius - goal_linewidth / 2,\n        goal_radius\n      );\n\n      var goals = two.current.makeGroup([\n        topleft_goal,\n        topcenter_goal,\n        topright_goal,\n        leftcenter_goal,\n        center_goal,\n        rightcenter_goal,\n        botleft_goal,\n        botcenter_goal,\n        botright_goal,\n      ]);\n      goals.fill = goal_fill;\n      goals.stroke = goal_stroke;\n      goals.linewidth = goal_linewidth;\n    };\n\n    startWidth.current = mount.current.getBoundingClientRect().width;\n    two.current = new Two({\n      width: startWidth.current,\n      height: startWidth.current,\n      autostart: true,\n    }).appendTo(mount.current);\n    two.current.makeGroup();\n\n    field();\n\n    window.addEventListener(\"resize\", () => {\n      savedBoundingRect.current = mount.current.getBoundingClientRect();\n      resize(savedBoundingRect.current.width);\n    });\n  }, []);\n\n  const resize = (width) => {\n    two.current.scene.scale = width / startWidth.current;\n    two.current.renderer.setSize(width, width);\n  };\n\n  /**\n   * Resizes the Two.js canvas each time the component updates.\n   */\n  useEffect(() => {\n    if (savedBoundingRect.current === null) {\n      // we have not yet saved a box size, store it\n      // We're storing the bounding client width because it updates out of\n      // sync with the Material UI drawer\n      savedBoundingRect.current = mount.current.getBoundingClientRect();\n    }\n    const boxWidth = savedBoundingRect.current.width;\n    if (props.open) {\n      savedLeft.current = props.drawerWidth;\n      resize(boxWidth - props.drawerWidth);\n    } else {\n      savedLeft.current = 0;\n      resize(boxWidth);\n    }\n  }, [props.open, props.drawerWidth]);\n\n  /**\n   * Handles the State Machine for the edit modes.\n   */\n  useEffect(() => {\n    console.log(props.paths);\n    if (props.mode === prevMode.current) {\n      // The below state machine only operates on the state transitions\n      return;\n    }\n\n    switch (props.mode) {\n      case \"ADD_PATH\":\n        removeAllEventListeners();\n        addNewEventListener(mount.current, \"click\", placePoints);\n        break;\n      case \"EDIT\":\n        removeAllEventListeners();\n\n        props.paths.forEach((p) => {\n          p.vectors.forEach((v) => {\n            addInteractivity(v.p);\n            addInteractivity(v.r);\n          });\n        });\n        break;\n      case \"ADD_POINTS\":\n        break;\n      case \"REMOVE_POINTS\":\n        break;\n      default:\n        break;\n    }\n    prevMode.current = props.mode;\n  });\n\n  return <div ref={mount}></div>;\n};\n",["40","41"],"/home/bayle/Documents/git/robotsquiggles/web-react/src/theme.js",[],"/home/bayle/Documents/git/robotsquiggles/web-react/src/components/sidebar.tsx",[],"/home/bayle/Documents/git/robotsquiggles/web-react/src/components/generated.tsx",["42"],{"ruleId":"43","replacedBy":"44"},{"ruleId":"45","replacedBy":"46"},{"ruleId":"47","severity":1,"message":"48","line":243,"column":9,"nodeType":"49","messageId":"50","endLine":243,"endColumn":20},{"ruleId":"43","replacedBy":"44"},{"ruleId":"45","replacedBy":"46"},{"ruleId":"51","severity":1,"message":"52","line":6,"column":8,"nodeType":"49","messageId":"50","endLine":6,"endColumn":18},"no-native-reassign",["53"],"no-negated-in-lhs",["54"],"no-unused-vars","'addMidpoint' is assigned a value but never used.","Identifier","unusedVar","@typescript-eslint/no-unused-vars","'Typography' is defined but never used.","no-global-assign","no-unsafe-negation"]